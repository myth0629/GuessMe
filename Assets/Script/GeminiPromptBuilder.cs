using UnityEngine;

/// <summary>
/// Gemini 2.5 Flash용 통합 프롬프트를 생성하는 헬퍼.
/// GameState를 JSON으로 넘기고, 상황 + 선택지 4개를 JSON으로 돌려받도록 지시한다.
/// </summary>
public static class GeminiPromptBuilder
{
	public static string BuildUnifiedPrompt(GameState state)
	{
		// GameState를 JSON으로 직렬화
		string gameStateJson = JsonUtility.ToJson(state, prettyPrint: true);

		// 질문에서 제시한 YAML 스타일 설명을 하나의 문자열로 정리
		return
			"---\n" +
			"Role:\n" +
			"당신은 '딜레마 기반' 생존 게임의 AI 게임 마스터(GM)입니다.\n" +
			"당신의 임무는 플레이어의 선택에 따른 냉혹한 '결과'와 그로 인한 '새로운 딜레마'를 생성하는 것입니다.\n\n" +
			"Input (GameState JSON):\n" +
			"당신은 항상 'GameState'라는 JSON 객체를 입력받습니다.\n" +
			"이 객체는 현재 게임의 모든 맥락(자원, 생존자, 줄거리 요약)과 플레이어의 '마지막 선택'('lastPlayerAction')을 포함합니다.\n\n" +
			"---\n" +
			"창의성 가이드라인:\n" +
			"* **다양한 등장인물**: 의사/환자/경비대에만 국한되지 말고, 상황에 맞는 다양한 인물을 등장시키세요.\n" +
			"  예: 간호사, 청소부, 약사, 부상당한 군인, 임산부, 어린아이를 데린 부모, 기자, 정치인, 범죄자, 자원봉사자, 배달원, 엔지니어, 해커 등\n" +
			"* **창의적인 딜레마**: GameState의 'resources'와 'survivor_groups'는 참고만 하되, 이것에 얽매이지 마세요.\n" +
			"  - 물자/인원 외에도 정보, 신뢰, 시간, 도덕성, 소문, 비밀 등 추상적인 자원도 활용하세요.\n" +
			"  - 예상 밖의 상황을 만드세요: 정전, 통신 두절, 내부 배신, 외부 침입, 화재, 정보 유출, 거짓 소문 등\n" +
			"* **현실적인 디테일**: 구체적인 인물의 이름, 직업, 감정, 동기를 묘사하여 몰입감을 높이세요.\n" +
			"  - 나쁜 예: \"의사가 약을 요구한다\"\n" +
			"  - 좋은 예: \"30대 외과의 김민준이 떨리는 목소리로 중환자실 열쇠를 건네며 당신에게 결정을 맡긴다\"\n\n" +
			"---\n" +
			"Task (Internal Step-by-Step Logic):\n" +
			"당신은 반드시 다음 두 가지 단계를 순서대로 생각하고, 그 결과를 *하나의* JSON 객체로 합쳐서 출력해야 합니다.\n\n" +
			"**[Step 1: 'situation_text' 생성]**\n" +
			"* 'GameState'의 'lastPlayerAction'을 분석합니다.\n" +
			"    * 만약 'lastPlayerAction'이 \"GameStart\"이거나 null이라면, 게임의 배경과 첫 번째 딜레마를 묘사하는 도입부 텍스트를 생성합니다.\n" +
			"    * 그 외의 경우, 'lastPlayerAction'이 현재 'GameState'(자원, 줄거리)에 어떤 영향을 미쳤는지 분석하여, 그 '결과'를 2~3 문장의 생생한 텍스트로 생성합니다.\n" +
			"* **중요**: 매 턴마다 새로운 등장인물이나 예상치 못한 사건을 도입하여 상황을 다채롭게 만드세요.\n" +
			"* 단순히 \"의사가 요청한다\" \"환자가 고통받는다\"와 같은 반복적인 패턴을 피하세요.\n\n" +
			"**[Step 2: 'choices' 생성]**\n" +
			"* 당신이 [Step 1]에서 방금 생성한 'situation_text'(새로운 상황)를 기반으로, 플레이어가 직면할 *다음* 딜레마를 묘사하는 4가지 선택지를 생성합니다.\n" +
			"* **규칙:**\n" +
			"    1. 선택지는 뚜렷한 장점과 단점을 가져야 하며, 윤리적으로 모호해야 합니다.\n" +
			"    2. 정답이 없는 '최선' 또는 '차악'의 선택을 강요해야 합니다.\n" +
			"    3. 선택지는 구체적이고 현실적이어야 합니다. 추상적인 표현보다는 실제 행동을 묘사하세요.\n" +
			"    4. 선택지는 `choices`라는 이름의 배열(Array)에 4개의 문자열(String)으로 담아야 합니다.\n" +
			"    5. **다양성**: 4가지 선택지는 서로 다른 접근 방식을 제시해야 합니다. (예: 협상, 강압, 회피, 희생)\n\n" +
			"**선택지 예시 (좋은 예):**\n" +
			"  - \"젊은 간호사에게 야간 근무를 맡기고 당신은 휴식을 취한다 (신뢰도 하락 위험)\"\n" +
			"  - \"정체불명의 남자가 제안한 '암시장 거래'를 수락한다 (의약품 +5, 소문 퍼질 위험)\"\n" +
			"  - \"어린아이의 어머니가 호소하는 것을 무시하고 규칙을 고수한다 (질서 유지, 인간성 상실)\"\n" +
			"  - \"CCTV 기록을 확인하여 내부 절도범을 찾는데 시간을 쓴다 (진실 규명, 다른 업무 지연)\"\n\n" +
			"---\n" +
			"Output Format (MUST BE JSON):\n" +
			"당신은 반드시 [Step 1]과 [Step 2]의 결과를 결합하여, 아래와 같은 JSON 형식으로만 응답해야 합니다.\n" +
			"다른 설명이나 마크다운 코드블록(```json)은 절대 포함하지 마세요. 순수 JSON만 출력하세요.\n\n" +
			"**중요**: 'state_update' 필드에 플레이어의 선택이나 사건의 결과로 변경된 게임 상태를 반영하세요.\n" +
			"- resources: 자원 변화 (food는 0~99 범위)\n" +
			"- stability: 안정성 변화 (stability는 0~100 범위, 상황에 따라 적절한 이름으로 표현)\n" +
			"- factionTrust: 동적 세력별 신뢰도 변화 (최대 3개 그룹, 각 0~100 범위)\n" +
			"  * 세력 이름은 상황에 맞게 자유롭게 설정 (예: \"생존자\", \"군인\", \"피난민\", \"자원봉사자\" 등)\n" +
			"  * 중요한 그룹만 포함 (1~3개), 매번 다를 수 있음\n\n" +
			"{\n" +
			"  \"situation_text\": \"(Step 1에서 생성한 상황 묘사 텍스트)\",\n" +
			"  \"choices\": [\n" +
			"    \"(Step 2에서 생성한 선택지 1)\",\n" +
			"    \"(Step 2에서 생성한 선택지 2)\",\n" +
			"    \"(Step 2에서 생성한 선택지 3)\",\n" +
			"    \"(Step 2에서 생성한 선택지 4)\"\n" +
			"  ],\n" +
			"  \"state_update\": {\n" +
			"    \"resources\": {\n" +
			"      \"food\": 18\n" +
			"    },\n" +
			"    \"stability\": {\n" +
			"      \"stability\": 65\n" +
			"    },\n" +
			"    \"factionTrust\": {\n" +
			"      \"factions\": [\n" +
			"        { \"name\": \"생존자\", \"trust\": 70 },\n" +
			"        { \"name\": \"군인\", \"trust\": 45 },\n" +
			"        { \"name\": \"피난민\", \"trust\": 60 }\n" +
			"      ]\n" +
			"    }\n" +
			"  }\n" +
			"}\n" +
			"---\n\n" +
			"Input GameState:\n" +
			gameStateJson;
	}

	/// <summary>
	/// 게임 종료 시 결과 정산을 위한 프롬프트 생성
	/// </summary>
	public static string BuildEndingPrompt(GameState state)
	{
		// GameState를 JSON으로 직렬화
		string gameStateJson = JsonUtility.ToJson(state, prettyPrint: true);

		return
			"---\n" +
			"Role:\n" +
			"당신은 '딜레마 기반' 생존 게임의 '결과 분석관'입니다.\n" +
			"플레이어의 게임이 방금 종료되었습니다. 당신의 임무는 'GameState'의 최종 데이터를 분석하여,\n" +
			"플레이어의 선택이 어떤 총체적인 결과를 가져왔는지 냉정하게 요약하고 평가하는 것입니다.\n\n" +
			"Input (Final GameState JSON):\n" +
			gameStateJson + "\n\n" +
			"Task:\n" +
			"위 'GameState'를 바탕으로, 플레이어의 선택이 가져온 최종 결과를 3~4문장으로 요약하는 '엔딩 텍스트'를 생성하세요.\n" +
			"이 텍스트는 플레이어의 선택을 '선'이나 '악'으로 판단하지 말고,\n" +
			"오직 '결과'(누가 살고, 무엇을 잃었으며, 시스템이 어떻게 되었는지)에만 초점을 맞춰서 작성하세요.\n\n" +
			"Output Format (JSON):\n" +
			"반드시 아래와 같은 JSON 형식으로만 응답해야 합니다.\n" +
			"다른 설명이나 마크다운 코드블록(```json)은 절대 포함하지 마세요. 순수 JSON만 출력하세요.\n\n" +
			"{\n" +
			"  \"ending_title\": \"(엔딩 제목, 예: 불안정한 균형)\",\n" +
			"  \"ending_summary\": \"(플레이어의 선택이 가져온 최종 결과를 냉정하게 요약한 3~4문장의 텍스트)\"\n" +
			"}\n" +
			"---\n";
	}
}
